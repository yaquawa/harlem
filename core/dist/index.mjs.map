{
  "version": 3,
  "sources": ["../src/event-emitter.ts", "../src/constants.ts", "../src/store.ts", "../src/utilities.ts", "../src/index.ts"],
  "sourcesContent": ["import type {\n    Emittable,\n    EventHandler,\n    EventListener,\n    EventPayload\n} from './types';\n\nexport class EventEmitter implements Emittable {\n\n    private listeners: Record<string, EventHandler[]>;\n\n    constructor() {\n        this.listeners = {};\n    }\n\n    public on(event: string, handler: EventHandler): EventListener {\n        if (!this.listeners[event]) {\n            this.listeners[event] = [];\n        }\n\n        this.listeners[event].push(handler);\n\n        return {\n            dispose: () => this.off(event, handler)\n        };\n    }\n\n    public off(event: string, handler: EventHandler): void {\n        const listeners = this.listeners[event];\n\n        if (!listeners) {\n            return;\n        }\n\n        this.listeners[event] = listeners.filter(listener => listener !== handler);\n\n        if (this.listeners[event].length === 0) {\n            delete this.listeners[event];\n        }\n    }\n\n    public once(event: string, handler: EventHandler): EventListener {\n        const callback = (payload?: EventPayload) => {\n            handler(payload);\n            this.off(event, callback);\n        };\n\n        return this.on(event, callback);\n    }\n\n    public emit(event: string, payload?: EventPayload): void {\n        const handlers = this.listeners[event];\n\n        if (!handlers) {\n            return;\n        }\n\n        handlers.forEach(handler => handler(payload));\n    }\n\n}\n\nexport default new EventEmitter();", "import type {\n    Options\n} from './types';\n\nexport const SENDER = 'core';\n\nexport const OPTIONS: Options = {\n    plugins: []\n};\n\nexport const EVENTS = {\n    core: {\n        installed: 'core:installed'\n    },\n    store: {\n        created: 'store:created',\n        destroyed: 'store:destroyed'\n    },\n    mutation: {\n        before: 'mutation:before',\n        after: 'mutation:after',\n        error: 'mutation:error'\n    }\n};", "import eventEmitter from './event-emitter';\n\nimport {\n    EVENTS,\n    SENDER\n} from './constants';\n\nimport {\n    reactive,\n    readonly,\n    computed,\n    ComputedRef\n} from 'vue';\n\nimport {\n    raiseDuplicationError\n} from './utilities';\n\nimport type {\n    EventHandler,\n    EventListener,\n    EventPayload,\n    Getter,\n    InternalStore,\n    Mutation,\n    MutationEventData,\n    Mutator,\n    ReadState,\n    WriteState\n} from './types';\n\nfunction localiseHandler(name: string, handler: EventHandler): EventHandler {\n    return payload => {\n        if (payload && payload.store === name) {\n            handler(payload);\n        }\n    };\n}\n\nexport default class Store<TState extends object = any> implements InternalStore<TState> {\n\n    private readState: ReadState<TState>;\n    private writeState: WriteState<TState>;\n\n    public name: string;\n    public getters: Map<string, Function>;\n    public mutations: Map<string, Mutation<any>>;\n\n    constructor(name: string, state: TState) {\n        this.writeState = reactive(state) as WriteState<TState>;\n        this.readState = readonly(this.writeState) as ReadState<TState>;\n        \n        this.name = name;\n        this.getters = new Map();\n        this.mutations = new Map();\n    }\n\n    public get state(): ReadState<TState> {\n        return this.readState;\n    }\n\n    public emit(event: string, sender: string, data: any): void {\n        const payload: EventPayload = {\n            data,\n            sender,\n            store: this.name\n        };\n\n        eventEmitter.emit(event, payload);\n    }\n\n    public on(event: string, handler: EventHandler): EventListener {\n        return eventEmitter.on(event, localiseHandler(this.name, handler));\n    }\n    \n    public once(event: string, handler: EventHandler): EventListener {\n        return eventEmitter.once(event, localiseHandler(this.name, handler));\n    }\n\n    public getter<TResult>(name: string, getter: Getter<TState, TResult>): ComputedRef<TResult> {\n        if (this.getters.has(name)) {\n            raiseDuplicationError('getter', name);\n        }\n\n        const output = computed(() => getter(this.state));\n\n        this.getters.set(name, () => output.value);\n        \n        return output;\n    };\n\n    private mutate<TPayload, TResult = void>(name: string, sender: string, mutator: Mutator<TState, TPayload, TResult>, payload: TPayload): TResult {\n        const eventData: MutationEventData<TPayload, TResult> = {\n            payload,\n            mutation: name\n        };\n\n        let result: TResult;\n\n        this.emit(EVENTS.mutation.before, sender, eventData);\n\n        try {\n            result = mutator(this.writeState, payload);\n        } catch (error) {\n            this.emit(EVENTS.mutation.error, sender, eventData);\n            throw error;\n        }\n\n        this.emit(EVENTS.mutation.after, sender, {\n            ...eventData,\n            result\n        });\n\n        return result;\n    }\n\n    public mutation<TPayload, TResult = void>(name: string, mutator: Mutator<TState, TPayload, TResult>): Mutation<TPayload, TResult> {\n        if (this.mutations.has(name)) {\n            raiseDuplicationError('mutation', name);\n        }\n\n        const mutation = ((payload: TPayload) => {\n            return this.mutate(name, SENDER, mutator, payload);\n        }) as Mutation<TPayload, TResult>;\n        \n        this.mutations.set(name, mutation);\n        \n        return mutation;\n    }\n\n    public exec<TResult = void>(name: string, payload?: any): TResult {\n        const mutation = this.mutations.get(name) as Mutation<any, TResult>;\n\n        if (!mutation) {\n            throw new Error(`No mutation found for ${name}`);\n        }\n\n        return mutation(payload);\n    }\n    \n    public write<TResult = void>(name: string, sender: string, mutator: Mutator<TState, undefined, TResult>): TResult {\n        return this.mutate(name, sender, mutator, undefined);\n    }\n\n}", "export function lockObject<T extends object>(input: T, exclusions: (keyof T)[]): T {\n    return new Proxy(input, {\n        get(target, prop) {\n            if (exclusions.includes(prop as keyof T)) {\n                throw new Error(`Access to property '${prop as string}' is denied`);\n            }\n\n            const value = target[prop as keyof T];\n\n            if (typeof value === 'function') {\n                return (...args: any[]) => Reflect.apply(value, target, args);\n            }\n\n            return value;\n        }\n    });\n}\n\nexport function raiseDuplicationError(type: string, name: string): void {\n\n}\n", "import InternalStore from './store';\n\nimport eventEmitter from './event-emitter';\n\nimport {\n    EVENTS,\n    OPTIONS,\n    SENDER\n} from './constants';\n\nimport {\n    lockObject,\n    raiseDuplicationError\n} from './utilities';\n\nimport type {\n    App,\n    Plugin\n} from 'vue';\n\nimport type {\n    EventHandler,\n    HarlemPlugin,\n    InternalStores,\n    MutationEventData,\n    Options,\n    Store\n} from './types';\n\nexport {\n    EVENTS\n} from './constants';\n\nexport * from './types';\n\nconst stores: InternalStores = new Map();\n\nlet installed = false;\n\nfunction emitCreated(store: InternalStore, state: any): void {\n    /*\n    This is necessary because the stores may be\n    created before the plugin has been installed.\n    */\n   const created = () => store.emit(EVENTS.store.created, SENDER, state);\n\n   if (installed) {\n       return created();\n   }\n\n   eventEmitter.once(EVENTS.core.installed, created);\n}\n\nfunction installPlugin(plugin: HarlemPlugin, app: App): void {\n    if (!plugin || typeof plugin.install !== 'function') {\n        return;\n    }\n\n    const {\n        name,\n        install\n    } = plugin;\n\n    const lockedStores = lockObject(stores, [\n        'set',\n        'delete',\n        'clear'\n    ]);\n\n    try {\n        install(app, eventEmitter, lockedStores);\n    } catch (error) {\n        console.warn(`Failed to install Harlem plugin: ${name}. Skipping.`);\n    }\n}\n\n\n\nexport const on = eventEmitter.on.bind(eventEmitter);\nexport const once = eventEmitter.once.bind(eventEmitter);\n\nexport function createStore<T extends object = any>(name: string, data: T, { allowOverwrite = false }: { allowOverwrite?: boolean } = {}): Store<T> {\n    if (stores.has(name) && !allowOverwrite) {\n        raiseDuplicationError('store', name);\n    }\n\n    const store = new InternalStore(name, data);\n\n    const destroy = () => {\n        store.emit(EVENTS.store.destroyed, SENDER, data);\n        stores.delete(name);\n    };\n\n    const getMutationHook = (eventName: string) => {\n        return <TPayload = any, TResult = any>(callback: EventHandler<MutationEventData<TPayload, TResult>>) => store.on(eventName, callback);\n    };\n\n    const onBeforeMutation = getMutationHook(EVENTS.mutation.before);\n    const onAfterMutation = getMutationHook(EVENTS.mutation.after);\n    const onMutationError = getMutationHook(EVENTS.mutation.error);\n\n    stores.set(name, store);\n    emitCreated(store, data);\n\n    return {\n        destroy,\n        onBeforeMutation,\n        onAfterMutation,\n        onMutationError,\n        state: store.state,\n        getter: store.getter.bind(store),\n        mutation: store.mutation.bind(store),\n        on: store.on.bind(store),\n        once: store.once.bind(store),\n    };\n}\n\nexport default {\n\n    install(app, options: Options = OPTIONS) {\n        const {\n            plugins\n        } = {\n            ...OPTIONS,\n            ...options\n        };\n\n        if (plugins) {\n            plugins.forEach(plugin => installPlugin(plugin, app));\n        }\n\n        installed = true;\n        eventEmitter.emit(EVENTS.core.installed);\n    }\n\n} as Plugin;\n"],
  "mappings": "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",
  "names": []
}
